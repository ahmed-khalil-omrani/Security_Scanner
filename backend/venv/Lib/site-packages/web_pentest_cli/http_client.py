"""
HTTP client wrapper with rate limiting, retries, and timeout handling
"""

import logging
import time
from typing import Dict, Optional, Any
import requests
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry

from .utils import RateLimiter, sanitize_for_logging

logger = logging.getLogger(__name__)


class HTTPClient:
    """
    HTTP client with rate limiting, retries, and request logging.
    """

    def __init__(
        self,
        rate_limit: float = 1.0,
        timeout: int = 10,
        max_retries: int = 3,
        user_agent: Optional[str] = None
    ):
        """
        Initialize HTTP client.

        Args:
            rate_limit: Requests per second (default: 1.0)
            timeout: Request timeout in seconds (default: 10)
            max_retries: Maximum retry attempts (default: 3)
            user_agent: Custom user agent string
        """
        self.rate_limiter = RateLimiter(rate_limit)
        self.timeout = timeout
        self.max_retries = max_retries

        # Default user agent
        self.user_agent = user_agent or (
            "ShieldScan/1.0 (Security Testing Tool; +https://github.com/yourusername/shieldscan)"
        )

        # Create session with retry strategy
        self.session = requests.Session()
        retry_strategy = Retry(
            total=max_retries,
            backoff_factor=1,
            status_forcelist=[429, 500, 502, 503, 504],
            allowed_methods=["HEAD", "GET", "OPTIONS", "POST"]
        )
        adapter = HTTPAdapter(max_retries=retry_strategy)
        self.session.mount("http://", adapter)
        self.session.mount("https://", adapter)

        # Request statistics
        self.stats = {
            'total_requests': 0,
            'successful_requests': 0,
            'failed_requests': 0,
            'total_bytes_received': 0
        }

    def _get_headers(self, custom_headers: Optional[Dict] = None) -> Dict[str, str]:
        """
        Build request headers.

        Args:
            custom_headers: Additional headers to include

        Returns:
            Complete headers dictionary
        """
        headers = {
            'User-Agent': self.user_agent,
            'Accept': '*/*',
            'Accept-Encoding': 'gzip, deflate',
            'Connection': 'keep-alive'
        }

        if custom_headers:
            headers.update(custom_headers)

        return headers

    def request(
        self,
        method: str,
        url: str,
        headers: Optional[Dict] = None,
        params: Optional[Dict] = None,
        data: Optional[Any] = None,
        allow_redirects: bool = True,
        verify_ssl: bool = True
    ) -> Optional[requests.Response]:
        """
        Make HTTP request with rate limiting and error handling.

        Args:
            method: HTTP method (GET, POST, etc.)
            url: Target URL
            headers: Custom headers
            params: Query parameters
            data: Request body data
            allow_redirects: Whether to follow redirects
            verify_ssl: Whether to verify SSL certificates

        Returns:
            Response object or None if request failed
        """
        # Apply rate limiting
        self.rate_limiter.wait_if_needed()

        # Build headers
        request_headers = self._get_headers(headers)

        # Log request (sanitized)
        logger.debug(f"Request: {method} {url}")
        logger.debug(f"Headers: {sanitize_for_logging(str(request_headers))}")

        try:
            start_time = time.time()

            response = self.session.request(
                method=method,
                url=url,
                headers=request_headers,
                params=params,
                data=data,
                timeout=self.timeout,
                allow_redirects=allow_redirects,
                verify=verify_ssl
            )

            elapsed = time.time() - start_time

            # Update statistics
            self.stats['total_requests'] += 1
            self.stats['successful_requests'] += 1
            self.stats['total_bytes_received'] += len(response.content)

            # Log response (sanitized)
            logger.debug(
                f"Response: {response.status_code} ({len(response.content)} bytes, "
                f"{elapsed:.2f}s)"
            )

            return response

        except requests.exceptions.Timeout:
            logger.warning(f"Request timeout: {url}")
            self.stats['total_requests'] += 1
            self.stats['failed_requests'] += 1
            return None

        except requests.exceptions.ConnectionError as e:
            logger.warning(f"Connection error: {url} - {str(e)}")
            self.stats['total_requests'] += 1
            self.stats['failed_requests'] += 1
            return None

        except requests.exceptions.RequestException as e:
            logger.error(f"Request failed: {url} - {str(e)}")
            self.stats['total_requests'] += 1
            self.stats['failed_requests'] += 1
            return None

    def get(self, url: str, **kwargs) -> Optional[requests.Response]:
        """Make GET request."""
        return self.request('GET', url, **kwargs)

    def post(self, url: str, **kwargs) -> Optional[requests.Response]:
        """Make POST request."""
        return self.request('POST', url, **kwargs)

    def head(self, url: str, **kwargs) -> Optional[requests.Response]:
        """Make HEAD request."""
        return self.request('HEAD', url, **kwargs)

    def options(self, url: str, **kwargs) -> Optional[requests.Response]:
        """Make OPTIONS request."""
        return self.request('OPTIONS', url, **kwargs)

    def get_stats(self) -> Dict[str, Any]:
        """
        Get request statistics.

        Returns:
            Dictionary with statistics
        """
        return self.stats.copy()

    def close(self):
        """Close HTTP session."""
        self.session.close()