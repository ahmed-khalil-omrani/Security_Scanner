"""
Vulnerability detection checks - OWASP Top 10 focus
All checks are non-destructive and safe-by-default
"""

import logging
import re
from typing import Dict, List, Optional, Any
from abc import ABC, abstractmethod
from urllib.parse import urlparse, parse_qs, urlencode, urlunparse

from .http_client import HTTPClient

logger = logging.getLogger(__name__)


class VulnerabilityResult:
    """Structured vulnerability finding."""

    def __init__(
        self,
        vuln_id: str,
        name: str,
        severity: str,
        confidence: str,
        description: str,
        evidence: str,
        remediation: str,
        url: Optional[str] = None,
        references: Optional[List[str]] = None
    ):
        self.vuln_id = vuln_id
        self.name = name
        self.severity = severity  # info, low, medium, high, critical
        self.confidence = confidence  # low, medium, high
        self.description = description
        self.evidence = evidence
        self.remediation = remediation
        self.url = url
        self.references = references or []

    def to_dict(self) -> Dict:
        """Convert to dictionary."""
        return {
            'vuln_id': self.vuln_id,
            'name': self.name,
            'severity': self.severity,
            'confidence': self.confidence,
            'description': self.description,
            'evidence': self.evidence,
            'remediation': self.remediation,
            'url': self.url,
            'references': self.references
        }


class VulnerabilityCheck(ABC):
    """Base class for vulnerability checks."""

    def __init__(self, http_client: HTTPClient, mode: str = 'passive'):
        self.client = http_client
        self.mode = mode  # 'passive' or 'active'

    @abstractmethod
    def check(self, target_url: str, context: Dict) -> List[VulnerabilityResult]:
        """
        Perform vulnerability check.

        Args:
            target_url: Target URL to check
            context: Additional context (forms, parameters, etc.)

        Returns:
            List of vulnerability results
        """
        pass

    @property
    @abstractmethod
    def check_id(self) -> str:
        """Return unique check identifier."""
        pass

    @property
    @abstractmethod
    def check_name(self) -> str:
        """Return human-readable check name."""
        pass


class SecurityHeadersCheck(VulnerabilityCheck):
    """Check for missing or misconfigured security headers."""

    @property
    def check_id(self) -> str:
        return "SEC-HEADERS-001"

    @property
    def check_name(self) -> str:
        return "Security Headers Check"

    def check(self, target_url: str, context: Dict) -> List[VulnerabilityResult]:
        """Check security headers."""
        results = []

        response = self.client.get(target_url)
        if not response:
            return results

        headers = {k.lower(): v for k, v in response.headers.items()}

        # Define required security headers
        security_headers = {
            'content-security-policy': {
                'severity': 'medium',
                'description': 'Content Security Policy (CSP) header is missing',
                'remediation': 'Implement CSP to prevent XSS and data injection attacks'
            },
            'x-frame-options': {
                'severity': 'medium',
                'description': 'X-Frame-Options header is missing',
                'remediation': 'Set X-Frame-Options to DENY or SAMEORIGIN to prevent clickjacking'
            },
            'x-content-type-options': {
                'severity': 'low',
                'description': 'X-Content-Type-Options header is missing',
                'remediation': 'Set X-Content-Type-Options to nosniff'
            },
            'strict-transport-security': {
                'severity': 'high',
                'description': 'Strict-Transport-Security (HSTS) header is missing',
                'remediation': 'Implement HSTS with max-age of at least 31536000 seconds'
            },
            'referrer-policy': {
                'severity': 'low',
                'description': 'Referrer-Policy header is missing',
                'remediation': 'Set Referrer-Policy to no-referrer or strict-origin-when-cross-origin'
            },
            'permissions-policy': {
                'severity': 'low',
                'description': 'Permissions-Policy header is missing',
                'remediation': 'Configure Permissions-Policy to control browser features'
            }
        }

        # Check for missing headers
        for header_name, info in security_headers.items():
            if header_name not in headers:
                results.append(VulnerabilityResult(
                    vuln_id=f"{self.check_id}-{header_name}",
                    name=f"Missing {header_name.upper()} Header",
                    severity=info['severity'],
                    confidence='high',
                    description=info['description'],
                    evidence=f"Header '{header_name}' not found in response",
                    remediation=info['remediation'],
                    url=target_url,
                    references=[
                        'https://owasp.org/www-project-secure-headers/',
                        'https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers'
                    ]
                ))

        # Check for weak CSP
        if 'content-security-policy' in headers:
            csp = headers['content-security-policy']
            if 'unsafe-inline' in csp or 'unsafe-eval' in csp:
                results.append(VulnerabilityResult(
                    vuln_id=f"{self.check_id}-csp-weak",
                    name="Weak Content Security Policy",
                    severity='medium',
                    confidence='high',
                    description='CSP contains unsafe-inline or unsafe-eval directives',
                    evidence=f"CSP: {csp[:200]}",
                    remediation='Remove unsafe-inline and unsafe-eval from CSP',
                    url=target_url
                ))

        return results


class CookieSecurityCheck(VulnerabilityCheck):
    """Check for insecure cookie configurations."""

    @property
    def check_id(self) -> str:
        return "COOKIE-SEC-001"

    @property
    def check_name(self) -> str:
        return "Cookie Security Check"

    def check(self, target_url: str, context: Dict) -> List[VulnerabilityResult]:
        """Check cookie security attributes."""
        results = []

        response = self.client.get(target_url)
        if not response:
            return results

        # Check Set-Cookie headers
        cookies = response.cookies

        if not cookies:
            return results

        for cookie in cookies:
            # Check for missing Secure flag
            if not cookie.secure and urlparse(target_url).scheme == 'https':
                results.append(VulnerabilityResult(
                    vuln_id=f"{self.check_id}-no-secure",
                    name="Cookie Without Secure Flag",
                    severity='medium',
                    confidence='high',
                    description=f"Cookie '{cookie.name}' lacks Secure flag",
                    evidence=f"Cookie: {cookie.name}",
                    remediation='Set Secure flag on all cookies in HTTPS context',
                    url=target_url,
                    references=['https://owasp.org/www-community/controls/SecureCookieAttribute']
                ))

            # Check for missing HttpOnly flag
            if not cookie.has_nonstandard_attr('HttpOnly'):
                results.append(VulnerabilityResult(
                    vuln_id=f"{self.check_id}-no-httponly",
                    name="Cookie Without HttpOnly Flag",
                    severity='medium',
                    confidence='high',
                    description=f"Cookie '{cookie.name}' lacks HttpOnly flag",
                    evidence=f"Cookie: {cookie.name}",
                    remediation='Set HttpOnly flag to prevent XSS cookie theft',
                    url=target_url,
                    references=['https://owasp.org/www-community/HttpOnly']
                ))

            # Check for missing SameSite attribute
            samesite = cookie.get_nonstandard_attr('SameSite')
            if not samesite:
                results.append(VulnerabilityResult(
                    vuln_id=f"{self.check_id}-no-samesite",
                    name="Cookie Without SameSite Attribute",
                    severity='low',
                    confidence='high',
                    description=f"Cookie '{cookie.name}' lacks SameSite attribute",
                    evidence=f"Cookie: {cookie.name}",
                    remediation='Set SameSite attribute to Strict or Lax',
                    url=target_url,
                    references=['https://owasp.org/www-community/SameSite']
                ))

        return results



class XSSReflectionCheck(VulnerabilityCheck):
    """Check for reflected XSS vulnerabilities using benign markers."""

    @property
    def check_id(self) -> str:
        return "XSS-REFLECT-001"

    @property
    def check_name(self) -> str:
        return "Reflected XSS Detection"

    def check(self, target_url: str, context: Dict) -> List[VulnerabilityResult]:
        """
        Check for reflected XSS using safe marker tokens.
        Only tests reflection, not exploitation.
        """
        results = []

        # Safe test marker (no script tags in passive mode)
        test_marker = "__SHIELDSCAN_XSS_TEST_TOKEN__"

        # Get URL parameters
        parsed = urlparse(target_url)
        params = parse_qs(parsed.query)

        if not params and self.mode == 'passive':
            # In passive mode, just check if URL has parameters
            return results

        # Test each parameter
        for param_name in params.keys():
            test_params = params.copy()
            test_params[param_name] = [test_marker]

            # Build test URL
            new_query = urlencode(test_params, doseq=True)
            test_url = urlunparse(parsed._replace(query=new_query))

            response = self.client.get(test_url)
            if not response:
                continue

            # Check if marker is reflected in response
            if test_marker in response.text:
                # Analyze context of reflection
                context_safe = self._analyze_reflection_context(response.text, test_marker)

                severity = 'low' if context_safe else 'high'
                confidence = 'medium'

                results.append(VulnerabilityResult(
                    vuln_id=f"{self.check_id}-{param_name}",
                    name="Potential Reflected XSS",
                    severity=severity,
                    confidence=confidence,
                    description=f"Parameter '{param_name}' reflects user input in response",
                    evidence=f"Test marker '{test_marker}' reflected in HTML response",
                    remediation='Sanitize and encode all user input before rendering. Use context-aware output encoding.',
                    url=test_url,
                    references=[
                        'https://owasp.org/www-community/attacks/xss/',
                        'https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html'
                    ]
                ))

        # Check forms from context
        forms = context.get('forms', [])
        for form in forms[:10]:  # Limit to 10 forms
            if form['method'] == 'GET':
                for input_field in form['inputs']:
                    if input_field.get('name'):
                        # Test form input
                        test_params = {input_field['name']: test_marker}
                        response = self.client.get(form['action'], params=test_params)

                        if response and test_marker in response.text:
                            results.append(VulnerabilityResult(
                                vuln_id=f"{self.check_id}-form-{input_field['name']}",
                                name="Potential Form-based Reflected XSS",
                                severity='medium',
                                confidence='medium',
                                description=f"Form input '{input_field['name']}' may be vulnerable to XSS",
                                evidence=f"Input reflection detected in form at {form['url']}",
                                remediation='Implement proper input validation and output encoding',
                                url=form['url']
                            ))

        return results

    def _analyze_reflection_context(self, html: str, marker: str) -> bool:
        """
        Analyze if the reflection occurs in a safe context.

        Returns:
            True if context appears safe, False otherwise
        """
        # Find marker in HTML
        marker_pos = html.find(marker)
        if marker_pos == -1:
            return True

        # Get surrounding context (100 chars before and after)
        start = max(0, marker_pos - 100)
        end = min(len(html), marker_pos + len(marker) + 100)
        context = html[start:end].lower()

        # Check for dangerous contexts
        dangerous_patterns = [
            r'<script[^>]*>',  # Inside script tag
            r'on\w+\s*=',      # Inside event handler
            r'javascript:',    # Inside javascript: URL
            r'<style',         # Inside style tag
        ]

        for pattern in dangerous_patterns:
            if re.search(pattern, context):
                return False

        return True


class SQLInjectionCheck(VulnerabilityCheck):
    """Check for SQL injection vulnerabilities using error-based detection."""

    @property
    def check_id(self) -> str:
        return "SQLI-001"

    @property
    def check_name(self) -> str:
        return "SQL Injection Detection"

    def check(self, target_url: str, context: Dict) -> List[VulnerabilityResult]:
        """
        Check for SQL injection using benign error-inducing payloads.
        """
        results = []

        # Only run in active mode with consent
        if self.mode != 'active':
            return results

        # Safe test payloads that may trigger errors without harm
        test_payloads = [
            "'",           # Single quote
            "''",          # Double single quote
            "' OR '1'='1", # Classic SQLi pattern (non-destructive)
            "1' OR '1'='1",
        ]

        # SQL error patterns
        error_patterns = [
            r"SQL syntax.*MySQL",
            r"Warning.*mysql_.*",
            r"MySQLSyntaxErrorException",
            r"valid MySQL result",
            r"PostgreSQL.*ERROR",
            r"Warning.*pg_.*",
            r"valid PostgreSQL result",
            r"Microsoft SQL Native Client error",
            r"ODBC SQL Server Driver",
            r"SQLServer JDBC Driver",
            r"Oracle error",
            r"ORA-\d{5}",
            r"SQL Server.*Error",
            r"Unclosed quotation mark",
            r"quoted string not properly terminated",
        ]

        compiled_patterns = [re.compile(p, re.IGNORECASE) for p in error_patterns]

        # Get URL parameters
        parsed = urlparse(target_url)
        params = parse_qs(parsed.query)

        if not params:
            return results

        # Test each parameter
        for param_name in params.keys():
            original_response = self.client.get(target_url)
            if not original_response:
                continue

            original_length = len(original_response.content)

            for payload in test_payloads:
                test_params = params.copy()
                test_params[param_name] = [payload]

                new_query = urlencode(test_params, doseq=True)
                test_url = urlunparse(parsed._replace(query=new_query))

                response = self.client.get(test_url)
                if not response:
                    continue

                # Check for SQL error messages
                error_found = False
                for pattern in compiled_patterns:
                    if pattern.search(response.text):
                        error_found = True
                        break

                # Check for significant response length difference
                length_diff = abs(len(response.content) - original_length)
                significant_diff = length_diff > 100

                if error_found:
                    results.append(VulnerabilityResult(
                        vuln_id=f"{self.check_id}-error-{param_name}",
                        name="Potential SQL Injection (Error-Based)",
                        severity='high',
                        confidence='high',
                        description=f"Parameter '{param_name}' may be vulnerable to SQL injection",
                        evidence=f"SQL error message detected with payload: {payload}",
                        remediation='Use parameterized queries (prepared statements) or ORM. Never concatenate user input into SQL queries.',
                        url=test_url,
                        references=[
                            'https://owasp.org/www-community/attacks/SQL_Injection',
                            'https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html'
                        ]
                    ))
                    break  # Found vulnerability, no need to test more payloads

                elif significant_diff and self.mode == 'active':
                    results.append(VulnerabilityResult(
                        vuln_id=f"{self.check_id}-behavior-{param_name}",
                        name="Possible SQL Injection (Behavioral)",
                        severity='medium',
                        confidence='low',
                        description=f"Parameter '{param_name}' shows behavior changes with SQL-like input",
                        evidence=f"Response length changed by {length_diff} bytes with payload: {payload}",
                        remediation='Investigate parameter for SQL injection. Use parameterized queries.',
                        url=test_url,
                        references=['https://owasp.org/www-community/attacks/SQL_Injection']
                    ))

        return results



class CORSMisconfigurationCheck(VulnerabilityCheck):
    """Check for CORS misconfigurations."""

    @property
    def check_id(self) -> str:
        return "CORS-001"

    @property
    def check_name(self) -> str:
        return "CORS Misconfiguration Check"

    def check(self, target_url: str, context: Dict) -> List[VulnerabilityResult]:
        """Check for CORS misconfigurations."""
        results = []

        # Test with a malicious origin
        test_origin = "https://evil.com"
        headers = {'Origin': test_origin}

        response = self.client.get(target_url, headers=headers)
        if not response:
            return results

        resp_headers = {k.lower(): v for k, v in response.headers.items()}

        # Check for wildcard CORS
        acao = resp_headers.get('access-control-allow-origin', '')

        if acao == '*':
            results.append(VulnerabilityResult(
                vuln_id=f"{self.check_id}-wildcard",
                name="CORS Wildcard Misconfiguration",
                severity='high',
                confidence='high',
                description='Access-Control-Allow-Origin is set to wildcard (*)',
                evidence=f"Access-Control-Allow-Origin: {acao}",
                remediation='Restrict CORS to specific trusted origins. Never use wildcard with credentials.',
                url=target_url,
                references=[
                    'https://owasp.org/www-community/attacks/CORS_OriginHeaderScrutiny',
                    'https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS'
                ]
            ))

        # Check if origin is reflected
        elif acao == test_origin:
            results.append(VulnerabilityResult(
                vuln_id=f"{self.check_id}-reflected-origin",
                name="CORS Reflected Origin",
                severity='high',
                confidence='high',
                description='Access-Control-Allow-Origin reflects arbitrary origins',
                evidence=f"Sent Origin: {test_origin}, Received: {acao}",
                remediation='Implement a whitelist of allowed origins instead of reflecting the Origin header.',
                url=target_url,
                references=['https://owasp.org/www-community/attacks/CORS_OriginHeaderScrutiny']
            ))

        # Check for credentials with wildcard
        acac = resp_headers.get('access-control-allow-credentials', '').lower()
        if acao == '*' and acac == 'true':
            results.append(VulnerabilityResult(
                vuln_id=f"{self.check_id}-wildcard-credentials",
                name="CORS Wildcard with Credentials",
                severity='critical',
                confidence='high',
                description='CORS allows credentials with wildcard origin',
                evidence='Access-Control-Allow-Origin: * with Access-Control-Allow-Credentials: true',
                remediation='Never use wildcard origin with credentials enabled.',
                url=target_url
            ))

        return results


class DirectoryListingCheck(VulnerabilityCheck):
    """Check for directory listing vulnerabilities."""

    @property
    def check_id(self) -> str:
        return "DIR-LIST-001"

    @property
    def check_name(self) -> str:
        return "Directory Listing Check"

    def check(self, target_url: str, context: Dict) -> List[VulnerabilityResult]:
        """Check for exposed directory listings."""
        results = []

        # Common directories to check
        test_dirs = [
            '/uploads/',
            '/images/',
            '/files/',
            '/backup/',
            '/temp/',
            '/assets/',
            '/static/',
            '/media/',
        ]

        parsed = urlparse(target_url)
        base_url = f"{parsed.scheme}://{parsed.netloc}"

        # Directory listing indicators
        listing_patterns = [
            r'<title>Index of /',
            r'<h1>Index of /',
            r'Parent Directory',
            r'Directory Listing',
            r'<title>Directory listing for /',
        ]
        compiled_patterns = [re.compile(p, re.IGNORECASE) for p in listing_patterns]

        for dir_path in test_dirs:
            test_url = base_url + dir_path

            response = self.client.get(test_url)
            if not response or response.status_code != 200:
                continue

            # Check for directory listing patterns
            listing_found = False
            for pattern in compiled_patterns:
                if pattern.search(response.text):
                    listing_found = True
                    break

            if listing_found:
                results.append(VulnerabilityResult(
                    vuln_id=f"{self.check_id}-{dir_path.strip('/')}",
                    name="Directory Listing Enabled",
                    severity='low',
                    confidence='high',
                    description=f"Directory listing is enabled at {dir_path}",
                    evidence=f"Directory listing page detected at {test_url}",
                    remediation='Disable directory listing in web server configuration.',
                    url=test_url,
                    references=['https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/02-Configuration_and_Deployment_Management_Testing/04-Review_Old_Backup_and_Unreferenced_Files_for_Sensitive_Information']
                ))

        return results


class OpenRedirectCheck(VulnerabilityCheck):
    """Check for open redirect vulnerabilities."""

    @property
    def check_id(self) -> str:
        return "OPEN-REDIR-001"

    @property
    def check_name(self) -> str:
        return "Open Redirect Check"

    def check(self, target_url: str, context: Dict) -> List[VulnerabilityResult]:
        """Check for open redirect vulnerabilities."""
        results = []

        # Only run in active mode
        if self.mode != 'active':
            return results

        # Common redirect parameter names
        redirect_params = [
            'redirect', 'url', 'next', 'goto', 'return',
            'returnUrl', 'redirect_uri', 'continue', 'dest', 'destination'
        ]

        # Test URL (use example.com as safe test)
        test_redirect = 'https://example.com'

        parsed = urlparse(target_url)
        params = parse_qs(parsed.query)

        # Check existing parameters
        for param_name in params.keys():
            if any(rp in param_name.lower() for rp in redirect_params):
                test_params = params.copy()
                test_params[param_name] = [test_redirect]

                new_query = urlencode(test_params, doseq=True)
                test_url = urlunparse(parsed._replace(query=new_query))

                response = self.client.get(test_url, allow_redirects=False)
                if not response:
                    continue

                # Check if redirected to our test URL
                if response.status_code in [301, 302, 303, 307, 308]:
                    location = response.headers.get('Location', '')
                    if test_redirect in location:
                        results.append(VulnerabilityResult(
                            vuln_id=f"{self.check_id}-{param_name}",
                            name="Open Redirect Vulnerability",
                            severity='medium',
                            confidence='high',
                            description=f"Parameter '{param_name}' allows arbitrary redirects",
                            evidence=f"Redirect to {test_redirect} succeeded via {param_name}",
                            remediation='Validate redirect URLs against a whitelist. Use relative URLs when possible.',
                            url=test_url,
                            references=[
                                'https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/11-Client-side_Testing/04-Testing_for_Client-side_URL_Redirect',
                                'https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html'
                            ]
                        ))

        return results


class ClickjackingCheck(VulnerabilityCheck):
    """Check for clickjacking vulnerabilities."""

    @property
    def check_id(self) -> str:
        return "CLICKJACK-001"

    @property
    def check_name(self) -> str:
        return "Clickjacking Check"

    def check(self, target_url: str, context: Dict) -> List[VulnerabilityResult]:
        """Check for clickjacking protection."""
        results = []

        response = self.client.get(target_url)
        if not response:
            return results

        headers = {k.lower(): v for k, v in response.headers.items()}

        # Check X-Frame-Options
        xfo = headers.get('x-frame-options', '').upper()

        # Check CSP frame-ancestors
        csp = headers.get('content-security-policy', '').lower()
        has_frame_ancestors = 'frame-ancestors' in csp

        if not xfo and not has_frame_ancestors:
            results.append(VulnerabilityResult(
                vuln_id=f"{self.check_id}-no-protection",
                name="Missing Clickjacking Protection",
                severity='medium',
                confidence='high',
                description='No clickjacking protection detected (missing X-Frame-Options and CSP frame-ancestors)',
                evidence='Neither X-Frame-Options nor CSP frame-ancestors directive found',
                remediation='Set X-Frame-Options to DENY or SAMEORIGIN, or use CSP frame-ancestors directive.',
                url=target_url,
                references=[
                    'https://owasp.org/www-community/attacks/Clickjacking',
                    'https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options'
                ]
            ))
        elif xfo == 'ALLOW-FROM':
            results.append(VulnerabilityResult(
                vuln_id=f"{self.check_id}-deprecated",
                name="Deprecated X-Frame-Options Directive",
                severity='low',
                confidence='high',
                description='X-Frame-Options ALLOW-FROM is deprecated',
                evidence=f"X-Frame-Options: {headers.get('x-frame-options')}",
                remediation='Use CSP frame-ancestors instead of X-Frame-Options ALLOW-FROM.',
                url=target_url
            ))

        return results


# Registry of all vulnerability checks
def get_all_checks(http_client: HTTPClient, mode: str = 'passive') -> List[VulnerabilityCheck]:
    """
    Get all available vulnerability checks.

    Args:
        http_client: HTTP client instance
        mode: Scanning mode ('passive' or 'active')

    Returns:
        List of vulnerability check instances
    """
    return [
        SecurityHeadersCheck(http_client, mode),
        CookieSecurityCheck(http_client, mode),
        XSSReflectionCheck(http_client, mode),
        SQLInjectionCheck(http_client, mode),
        CORSMisconfigurationCheck(http_client, mode),
        DirectoryListingCheck(http_client, mode),
        OpenRedirectCheck(http_client, mode),
        ClickjackingCheck(http_client, mode),
    ]

